{"version":3,"sources":["../src/datasource.js"],"names":["_","GenericDatasource","instanceSettings","$q","backendSrv","type","url","name","q","datasourceRequest","method","then","response","status","message","title","options","query","filterPlaceholders","targets","filter","target","hide","length","data","entries","Array","apply","map","datapoints","parent","apiEndpoint","senmlValues","float","string","bool","recursiveReq","idi","senmlValue","Types","metric","senmlFields","value","time","range","from","toISOString","to","d","nextlink","nextLink","convertData","push","entry","convertMetrics","res","streams","i","dataType","text"],"mappings":"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","file":"datasource.js","sourcesContent":["// Copyright 2016 Fraunhofer Institute for Applied Information Technology FIT\r\n\r\nimport _ from \"lodash\";\r\n\r\nexport class GenericDatasource {\r\n\r\n  constructor(instanceSettings, $q, backendSrv) {\r\n    this.type = instanceSettings.type;\r\n    this.url = instanceSettings.url;\r\n    this.name = instanceSettings.name;\r\n    this.q = $q;\r\n    this.backendSrv = backendSrv;\r\n  }\r\n\r\n  // Required\r\n  // Used for testing datasource in datasource configuration page\r\n  testDatasource() {\r\n    return this.backendSrv.datasourceRequest({\r\n      url: this.url + '/health',\r\n      method: 'GET'\r\n    }).then(response => {\r\n      if (response.status === 200) {\r\n        return {status: \"success\", message: \"Data source is working\", title: \"Success\"};\r\n      }\r\n    });\r\n  }\r\n\r\n  // Query data from Data API\r\n  // Called once per panel (graph)\r\n  query(options) {\r\n    var query = this.filterPlaceholders(options);\r\n    //console.log(\"query QUERY:\", JSON.stringify(query));\r\n\r\n    // Filter targets that are set to hidden\r\n    query.targets = _.filter(query.targets, target => {\r\n      return target.hide != true;\r\n    });\r\n\r\n    // All targets filtered OR no metric selected\r\n    if (query.targets.length == 0 || !('metric' in query.targets[0])) {\r\n      return {data: []}; // return this.q.when([]);\r\n    }\r\n\r\n    // Make a new array with zero-valued object fields\r\n    var entries = Array.apply(null, Array(query.targets.length)).map(function () {\r\n      return {target: '', datapoints: []};\r\n    });\r\n\r\n    var parent = this;\r\n\r\n    const apiEndpoint = \"data/\";\r\n    const senmlValues = {float: \"v\", string: \"sv\", bool: \"bv\"}\r\n    // Recursively query all pages of every target\r\n    function recursiveReq(idi,url) {\r\n\r\n      var target = query.targets[idi];\r\n      var senmlValue = senmlValues[target.Types[target.metric]];\r\n      var senmlFields = {value: senmlValue, time: \"t\"};\r\n\r\n      if (url == \"\"){\r\n        url = parent.url + \"/\" + apiEndpoint + target.metric +\r\n        '?from=' + query.range.from.toISOString() + '&to=' + query.range.to.toISOString()\r\n      }else{\r\n        url = parent.url + url\r\n      }\r\n      return parent.backendSrv.datasourceRequest({\r\n        url: url ,\r\n        data: query,\r\n        method: 'GET'\r\n      }).then(function (d) {\r\n        var nextlink = d.data.nextLink; \r\n        var datapoints = parent.convertData(d.data, senmlFields);\r\n        // append aggregate name to metric title\r\n        entries[idi].target = target.metric \r\n        entries[idi].datapoints.push(...datapoints);\r\n\r\n        if (nextlink != \"\") {\r\n          // query the next page\r\n          return recursiveReq( idi,nextlink);\r\n        } else if (idi < query.targets.length - 1) {\r\n          // one target done, query the next target\r\n          return recursiveReq(++idi,\"\");\r\n        } else {\r\n          // all done\r\n          d.data = entries;\r\n          return d;\r\n        }\r\n\r\n      });\r\n    } // end func\r\n   \r\n    return recursiveReq(0,\"\");\r\n  }\r\n\r\n  // Convert historical SenML data from Data/Aggr API to Grafana datapoints\r\n  convertData(data, senmlFields) {\r\n    /*var datapoints = Array(data.data.length);\r\n    for (var i = 0; i < data.data.length; i++) {\r\n      datapoints[i] = [data.data[i][senmlFields.value], data.data[i][senmlFields.time] * 1000];\r\n    }*/\r\n    var datapoints = _.map(data.data, entry => {\r\n      return [entry[senmlFields.value], entry[senmlFields.time] * 1000];\r\n    });\r\n    return datapoints;\r\n  }\r\n\r\n  // Remove targets that have unselected metric or source\r\n  filterPlaceholders(options) {\r\n    options.targets = _.filter(options.targets, target => {\r\n      return target.metric !== 'select metric';\r\n    });\r\n\r\n    return options;\r\n  }\r\n\r\n  // Query list of metrics from Registry API\r\n  // Required for templating\r\n  queryMetrics(options) {\r\n    return this.backendSrv.datasourceRequest({\r\n      //url: this.url + '/search',\r\n      url: this.url + '/registry',\r\n      data: options,\r\n      method: 'GET',\r\n      //headers: { 'Content-Type': 'application/json' }\r\n    }).then(this.convertMetrics);\r\n  }\r\n\r\n  // Convert registration from Registry API to the format required by Grafana + some meta information\r\n  convertMetrics(res) {\r\n    return _.map(res.data.streams, (d, i) => {\r\n      return {\r\n        type: d.dataType,\r\n        text: d.name,\r\n        value: i\r\n      };\r\n    });\r\n  }\r\n \r\n}\r\n"]}